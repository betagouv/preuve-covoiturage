import { provider } from '@ilos/common';
import { promisify } from 'util';
import { PostgresConnection, Cursor } from '@ilos/connection-postgres';

import { IncentiveRepositoryProviderInterfaceResolver } from '../interfaces';
import {
  IncentiveStateEnum,
  IncentiveStatusEnum,
  SerializedIncentiveInterface,
  SerializedMetadataVariableDefinitionInterface,
} from '~/engine/interfaces';
import { IncentiveStatsInterface } from '~/interfaces/IncentiveRepositoryProviderInterface';

@provider({
  identifier: IncentiveRepositoryProviderInterfaceResolver,
})
export class IncentiveRepositoryProvider implements IncentiveRepositoryProviderInterfaceResolver {
  public readonly table = 'policy.incentives';
  public readonly tripTable = 'policy.trips';

  constructor(protected connection: PostgresConnection) {}

  async disableOnCanceledTrip(): Promise<void> {
    console.debug(`DISABLE_ON_CANCELED_TRIPS`);
    const query = {
      text: `
        UPDATE ${this.table} AS pi
        SET
          state = 'disabled'::policy.incentive_state_enum,
          status = 'error'::policy.incentive_status_enum
        FROM ${this.tripTable} AS pt
        WHERE
          pt.carpool_id = pi.carpool_id AND
          pt.carpool_status <> 'ok'::carpool.carpool_status_enum
      `,
      values: [],
    };

    await this.connection.getClient().query(query);
  }

  async lockAll(before: Date): Promise<void> {
    const query = {
      text: `
        UPDATE ${this.table}
          SET status = $1::policy.incentive_status_enum
        WHERE
          datetime <= $2::timestamp AND
          status = $3::policy.incentive_status_enum
      `,
      values: ['validated', before, 'draft'],
    };

    await this.connection.getClient().query(query);
  }

  async updateStatefulAmount(data: SerializedIncentiveInterface[], status?: IncentiveStatusEnum): Promise<void> {
    const idSet: Set<string> = new Set();

    // get only last incentive for each carpool / policy
    const filteredData = data.reverse().filter((d) => {
      const key = `${d.policy_id}/${d.carpool_id}`;
      if (idSet.has(key)) {
        return false;
      }
      idSet.add(key);
      return true;
    });

    // pick values for the given keys. Override status if defined
    const values: [Array<number>, Array<number>, Array<IncentiveStatusEnum>] = filteredData.reduce(
      ([ids, amounts, statuses], i) => {
        ids.push(i._id);
        amounts.push(i.statefulAmount);
        statuses.push(status ?? i.status);
        return [ids, amounts, statuses];
      },
      [[], [], []],
    );

    const query = {
      text: `
      WITH data AS (
        SELECT * FROM UNNEST (
          $1::int[],
          $3::int[],
          $4::policy.incentive_status_enum[]
        ) as t(
          _id,
          amount,
          status
        )
      )
      UPDATE ${this.table} as pi
      SET (
        amount,
        state,
        status
      ) = (
        data.amount,
        CASE WHEN data.amount = 0 THEN 'null'::policy.incentive_state_enum ELSE state END,
        data.status
      )
      FROM data
      WHERE
        data._id = pi._id
      `,
      values: [...values],
    };

    await this.connection.getClient().query(query);
  }

  async *findDraftIncentive(
    to: Date,
    batchSize = 100,
    from?: Date,
  ): AsyncGenerator<SerializedIncentiveInterface[], void, void> {
    const resCount = await this.connection.getClient().query({
      text: `
      SELECT
        count(*)
      FROM ${this.table}
      WHERE
        status = $1::policy.incentive_status_enum
        ${from ? 'AND datetime >= $3::timestamp' : ''}
        AND datetime <= $2::timestamp
      `,
      values: ['draft', to, ...(from ? [from] : [])],
    });

    console.debug(`FOUND ${resCount.rows[0].count} incentives to process`);

    const query = {
      text: `
      SELECT
        _id,
        carpool_id,
        policy_id,
        datetime,
        result as statelessAmount,
        amount as statefulAmount,
        status,
        state,
        meta
      FROM ${this.table}
      WHERE
        status = $1::policy.incentive_status_enum
        ${from ? 'AND datetime >= $3::timestamp' : ''}
        AND datetime <= $2::timestamp
      ORDER BY datetime ASC;
      `,
      values: ['draft', to, ...(from ? [from] : [])],
    };

    const client = await this.connection.getClient().connect();
    const cursor = client.query(new Cursor(query.text, query.values));
    const promisifiedCursorRead = promisify(cursor.read.bind(cursor));

    let count = 0;
    do {
      try {
        const rows = await promisifiedCursorRead(batchSize);
        count = rows.length;
        if (count > 0) {
          yield rows;
        }
      } catch (e) {
        cursor.close(() => client.release());
        throw e;
      }
    } while (count > 0);
    cursor.close(() => client.release());
  }

  async createOrUpdateMany(data: SerializedIncentiveInterface[]): Promise<void> {
    const idSet: Set<string> = new Set();
    const filteredData = data
      .reverse()
      .filter((d) => {
        const key = `${d.policy_id}/${d.carpool_id}`;
        if (idSet.has(key)) {
          return false;
        }
        idSet.add(key);
        return true;
      })
      .map((i) => ({
        ...i,
        status: i.status || 'validated',
        state: i.statefulAmount === 0 ? IncentiveStateEnum.Null : IncentiveStateEnum.Regular,
        meta: i.meta || {},
      }));

    const values: [
      Array<number>,
      Array<number>,
      Array<Date>,
      Array<number>,
      Array<number>,
      Array<IncentiveStatusEnum>,
      Array<IncentiveStateEnum>,
      Array<SerializedMetadataVariableDefinitionInterface>,
    ] = filteredData.reduce(
      ([policyIds, carpoolIds, datetimes, statelessAmounts, statefulAmounts, statuses, states, metas], i) => {
        policyIds.push(i.policy_id), carpoolIds.push(i.carpool_id), datetimes.push(i.datetime);
        statelessAmounts.push(i.statelessAmount),
          statefulAmounts.push(i.statefulAmount),
          statuses.push(i.status),
          states.push(i.state),
          metas.push(i.meta);
        return [policyIds, carpoolIds, datetimes, statelessAmounts, statefulAmounts, statuses, states, metas];
      },
      [[], [], [], [], [], [], [], []],
    );

    const query = {
      text: `
        INSERT INTO ${this.table} (
          policy_id,
          carpool_id,
          datetime,
          result,
          amount,
          status,
          state,
          meta
        ) SELECT * FROM UNNEST(
          $1::int[],
          $2::int[],
          $3::timestamp[],
          $4::int[],
          $5::int[],
          $6::policy.incentive_status_enum[],
          $7::policy.incentive_state_enum[],
          $8::json[]
        )
        ON CONFLICT (policy_id, carpool_id)
        DO UPDATE SET (
          result,
          amount,
          status,
          state,
          meta
        ) = (
          excluded.result,
          excluded.amount,
          excluded.status,
          excluded.state,
          excluded.meta
        )
      `,
      values,
    };

    await this.connection.getClient().query(query);
    return;
  }

  async getPolicyIncentiveStats(policy_id: number): Promise<IncentiveStatsInterface> {
    const query = {
      text: `
        SELECT
          coalesce(sum(amount)::int, 0) as amount,
          (count(*) FILTER (WHERE amount > 0))::int as trip_subsidized,
          (count(*) FILTER (WHERE amount = 0))::int as trip_excluded
        FROM ${this.table}
        WHERE policy_id = $1
          AND state = 'regular'
      `,
      values: [policy_id],
    };

    const result = await this.connection.getClient().query(query);

    return result.rowCount
      ? result.rows[0]
      : {
          amount: 0,
          trip_excluded: 0,
          trip_subsidized: 0,
        };
  }
}
